==============================================================================================================================
###) Error Boundary::->Error Boundaries basically provide some sort of boundaries or checks on errors,They are React components that are used to handle JavaScript errors in their child component tree.
In React, "error boundaries" are components that catch JavaScript errors anywhere in their child component tree, log those errors, and display a fallback UI instead of crashing the entire React application. They are a feature introduced in React 16 to improve the error-handling experience in applications.

   How Error Boundaries Work::->  To define an error boundary in your React application, you create a component that extends React.Component and implements either or both of the lifecycle methods static getDerivedStateFromError(error) or componentDidCatch(error, errorInfo).

static getDerivedStateFromError(error):- This method is used to update state when an error is thrown by a descendant component. It allows the component to render a fallback UI after an error occurs. It only say there is error or not.

componentDidCatch(error, errorInfo): This method is called after an error has been thrown by a descendant component. It say there is error or not and also send the info of error.
It receives two parameters:
error: The error that was thrown.
errorInfo: An object with a componentStack key containing information about which component threw the error.
Usage::: You wrap components that you suspect might throw errors in your application with the error boundary component. This way, if any error occurs within that subtree of components, the error boundary will catch it and handle it gracefully.


Key Points to Remember::::-->
Propagation:: Error boundaries catch errors during rendering, in lifecycle methods, and in constructors of the whole tree below them.

Single Responsibility:: Each error boundary covers its own subtree, and they do not catch errors for the whole application. You can have multiple error boundaries in a single application.

Class Components:: Error boundaries are regular React components defined as classes. They only catch errors in components below them in the tree, not above.

Function Components:: Starting from React 16.6, you can also use error boundaries with function components using the useErrorBoundary hook from libraries like react-error-boundary.
note::- Error boundries help in which components have error only effect them and rest of the whole app will not crash.

1)static getDrivedStateFromErro(error) {
return {hasError:true};
}    //will tell only there is error or not ,it will not give the info about error.

2) componentDidCatch(error,errorInfo) {
 logErrorToMyService(error,errorInfo);
}   //will tell the error and as well as will give the error info.

===============================================================================================================================
===============================================================================================================================
###) Explain the purpose of Higher-Order Components (HOCs) in React. Give an example of when you would use one. ?
:::::When you pass a component to a function and it returns a new component, itâ€™s called a higher-order component (HOC). 
Higher-Order Components (HOCs) in React are a design pattern used for reusing component logic. They are functions that accept a component as an argument and return a new component with enhanced functionality. The main purpose of HOCs is to share common functionality between components without repeating code.

Purpose of HOCs/Why we use:::: 1) Code Reuse: HOCs allow you to extract common logic from components and reuse it across different parts of your application. This promotes cleaner and more maintainable code.
2)Props Manipulation: HOCs can manipulate props or inject additional props into components before rendering, which can be useful for providing data or behaviors to components based on certain conditions.

Example of when to use a HOC:::::: Consider a scenario where you have multiple components in your React application that need to fetch data from an API endpoint. Instead of duplicating the data fetching logic in each component, you can create a HOC to handle the data fetching and then pass the fetched data as props to the components.

A) HOC component ---
import React,{Component} from "react";


const AreaOFRatings = (SUBCOMP) =>{

    class AreaOFRating extends Component {
        render(){
            return (
                <SUBCOMP hocsub="JAVASCRIPT"></SUBCOMP>
            )
        }
    }
    return AreaOFRating;
}

export default AreaOFRatings;


B)  normal component which wil pass to HOC componet:
import React from "react";
import AreaOFRatings from "./HOC";
class User1 extends React.Component {
    state={
        rating:0
    }

    RatingInc = ()=>{
        this.setState({rating:this.state.rating+1})
    }
    render() {

        return (
            <div>
                <h2 onMouseOver={this.RatingInc}>User1 Rank: {this.state.rating},{this.props.hocsub}</h2>
            </div>
        )
    }
}
export default AreaOFRatings(User1);

C) another  normal component which wil pass to HOC componet:
import React from "react";
import AreaOFRatings from "./HOC";
class User2 extends React.Component {
    state={
        rating:0
    }

    RatingInc = ()=>{
        this.setState({rating:this.state.rating+1})
    }
    render() {

        return (
            <div>
                <h2 onMouseOver={this.RatingInc}>User2 Rank: {this.state.rating}, {this.props.hocsub}</h2>
            </div>
        )
    }
}
export default AreaOFRatings(User2);

D) Main component APP :
import './App.css';
import User1 from './Components/User1.jsx';
import User2 from './Components/USer2.jsx';
function App() {
  return (
    <>
       <h5>HOC COMPONENTS</h5>
       <hr />
      <User1></User1>
      <User2></User2>
    </>
  );
}

export default App;

===============================================================================================================================
===============================================================================================================================
###) What are hooks in React? How do they differ from class components?
    Hooks were added to React in version 16.8.
Hooks in React are functions that allow you to use state and other React features in functional components instead of class components. 
    Hooks in React differ from class components in several key ways::::

1.Function vs Class Syntax:: Hooks allow you to use state and other React features directly in functional components, whereas class components use ES6 class syntax to define a component with its state and lifecycle methods.
2.State Management:: In function components with hooks, you use the useState hook to add state to a functional component, whereas in class components, state is declared using this.state and modified using this.setState.
3. Lifecycle Methods:: Hooks provide lifecycle functionalities (like useEffect for handling side effects) directly within function components. Class components use lifecycle methods (componentDidMount, componentDidUpdate, etc.) for similar purposes.
4.Readability and Maintainability:: Hooks generally lead to more concise and readable code compared to class components, especially for simpler components that don't require the full power of class-based architecture.
5. Ease of Testing:: Functional components with hooks are easier to test because you can test them like regular functions without needing to deal with the complexities of class instance methods and lifecycle methods.
Types of hooks in reactjs:-
1) useState():- Allows functional components to manage local state.
ex:- const[count setCount] = useState(0);

2) useReducer():- Alternative to useState for more complex state management.
ex:- const [state, dispatch] = useReducer(reducer, initialState);

3)useEffect():-Allows functional components to perform side effects.
Some examples of side effects are: fetching data, directly updating the DOM, and timers.
useEffect accepts two arguments. The second argument is optional.
useEffect(<function>, <dependency>)
Similar to componentDidMount, componentDidUpdate, and componentWillUnmount in class components.
Ex: useEffect(() => {
  // Effect code
  return () => {
    // Cleanup code
  };
}, [dependencies]);

4) useContext():- Allows functional components to consume context. (It is solution of Props drilling in react components.)
Ex:-const value = useContext(MyContext);

5) useRef() :- Returns a mutable ref object whose .current property is initialized to the passed argument.
Useful for accessing DOM nodes or storing mutable values.
Ex:- const inputRef = useRef(initialValue);

6) useMemo():- Memoizes a value computation and returns the memoized value.  Useful for optimizing performance by caching expensive calculations.
Ex:- const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);

===============================================================================================================================
===============================================================================================================================
###) Describe the significance of React's Context API. When would you prefer using Context over props drilling?

###) Compare React's server-side rendering (SSR) vs. client-side rendering (CSR). When would you choose one over the other in a project?

###) How does React handle state management? Discuss the use of Redux with React and explain the benefits of using Redux in a large application.

###) What are React Fragments? How and why would you use them in your components?

###) Explain the concept of reconciliation in React. What strategies can you employ to optimize reconciliation performance?

###) Discuss the differences between controlled and uncontrolled components in React forms. When would you use each type?

###) How does React handle lifecycle methods in functional components? What are the equivalents of componentDidMount and componentDidUpdate in functional components with hooks?

###) Describe the role of React Router in a React application. How would you implement nested routing using React Router v5 or v6?

###) What are the benefits of using TypeScript with React? How does TypeScript enhance the development process in a React project?

###) Explain the concept of virtual DOM in React. How does it contribute to React's performance compared to traditional DOM manipulation?

###) How do you optimize a React application for performance? Discuss some tools and techniques you've used to measure and improve performance in your previous projects.

###) What are the key differences between React 16 and React 17? How has the React ecosystem evolved between these versions?

###) Discuss the importance of code splitting in a React application. How would you implement code splitting using React.lazy() and Suspense?
###) How many hooks in react Explain it ?




















